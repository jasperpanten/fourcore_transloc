---
title: "FCG Liver Preprocessing and annotation"
---

```{r init_}

# reinstall scir if there are updates:
devtools::install_github("odomlab2/scir")

# Import libraries ----
suppressPackageStartupMessages({library(dplyr)
library(monocle3)
library(BiocParallel)
library(scDblFinder)
library(scir)
library(ggplot2)
library(scales)})

# Parallel settings ----
future::plan(future::multisession, workers = 10)

# Set seed.
base::set.seed(708813)

# Set plot theme.
theme_paper <- function(textsize = 8){
  theme(panel.background = element_blank(),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = "black"),
        panel.border = element_rect(colour = "black", fill=NA, size=1), 
        text = element_text(size = textsize, color = "black"), 
        axis.text = element_text(size = textsize, color = "black"), 
        axis.ticks = element_line(colour = 'black', size = 1), 
        axis.ticks.length = unit(.25, "cm"))
}

```

Load annotated and processed cds generated by this notebook:

```{r load_processed_cds}
#cds <- readRDS("../data/rdata/fcg_mess_grp-aligned_cds.RDS")
cds <- readRDS("../data/rdata/fcg_mess_grp-aligned_cds2.RDS")
```


Import samples and generate QC plots: 

```{r sort_metadata}
metadata <- readxl::read_xlsx(
    path = "../data/tables/suppl_table2_mousedata_transloc.xlsx") %>% 
  dplyr::filter(!is.na(sequencing_name)) %>% 
  dplyr::mutate(sample_name = sequencing_name) %>% 
  dplyr::arrange(sample_name)
```

## Import count matrices (`monocle3`).

We import and combine all samples into a single `cell_data_set` object with gene-annotations. We only import the filtered matrices of STARSolo-determined true cells.

```{r load_cds}

cds <- import_samples_monocle(
  folder = "../data/data/sci-rocket/sx42b/alignment/",
  samples = unique(metadata$sample_name),
  gtf = "../data/data/annotations/gencode.vM31.basic.annotation.gtf",
  metadata = metadata
)

#. check feature number
nrow(cds)

```

## Determine no. of relevant PCs

To perform an optimal dimension reduction, we determine the number of principal components (PCs) which capture at least \~1% of total variance within the data (all genes) and only use these within the UMAP reduction.

```{r determine_pcs}
#| label: fig-scree
#| fig-cap: "Overview of explained variance per principal component (PC)."
#| cap-location: margin
cds <- monocle3::preprocess_cds(cds, method = "PCA", num_dim = 50)
chosen_pc <- sum(cds@reduce_dim_aux[["PCA"]][["model"]][["prop_var_expl"]] >= 0.01)
scir::plot_screeplot(cds, pc_total = 50, pc_chosen = chosen_pc, pc_threshold = 0.01)
```

## Run `monocle3` workflow.

Using the optimal no. of relevant PCs, we continue the default workflow of `monocle3`. We regress out the effect of differing no. of UMI's per cell (`residual_model_formula_str = "~n.umi"`).

```{r process_cds}
# Reset future.
future::plan(future::sequential())

# add log.n.umis to the metadata
colData(cds)$log.n.umi <- log10(colData(cds)$n.umi)

# Monocle3 workflow.
cds <- cds %>%
    monocle3::preprocess_cds(method = "PCA", num_dim = 30) %>%
    monocle3::detect_genes(.) %>%
    monocle3::align_cds(., alignment_group = "group", residual_model_formula_str = "~log.n.umi")

cds <- monocle3::reduce_dimension(cds, reduction_method = "UMAP", cores = 10, 
                               umap.min_dist = 0.1) %>%
    monocle3::cluster_cells(., cluster_method = "leiden", resolution = 2e-5)

plot_cells(cds, color_cells_by = "cluster", 
           label_cell_groups = T, group_label_size = 4)

```

## Detection of doublets.

We use `scDblFinder` to detect cells which resemble artificial combinations of major cell-clusters in order the detect potential doublets. We assume a doublet rate of max. 2% for all cells (`dbr`) and generate 25,000 artificial doublets.

#### Predict potential doublets.

```{r run_scDblFinder}
sce <- scDblFinder::scDblFinder(
    sce = cds,
    # Detect doublets between major clusters in UMAP-space.
    clusters = monocle3::clusters(cds),
    includePCs = chosen_pc, 
    # We assume a max. doublet formation rate of 2%.
    dbr = .02, 
    # Use 2500 most-variable genes.
    nfeatures = 2500#,
    # Perform in parallel.
    #BPPARAM = BiocParallel::MulticoreParam(10)
)

# Retrieve predictions.
results_scDblFinder <- SummarizedExperiment::colData(sce) %>% 
    tibble::as_tibble(rownames = "cell_id") %>%
    dplyr::select(cell_id, dplyr::contains("scDblFinder"))

# Add to original cds.
monocle3::pData(cds) <- monocle3::pData(cds) %>%
    tibble::as_tibble(rownames = "cell_id") %>%
    dplyr::left_join(results_scDblFinder, by = c('cell_id' = 'cell_id')) %>%
    tibble::column_to_rownames("cell_id") %>%
    S4Vectors::DataFrame()

# Remove sce object.
rm(sce)
```

## Heuristic filtering.

Prior to downstream processing, we also determine whether to filter out additional cells based on the abnormal expression of mitochondrial genes (**a**), number of expressed genes (â‰¥1 UMI) and/or the number of UMI (**b**). For this, we plot the distribution of these features and determine the threshold for potential filtering based on: $$\mu * 3\sigma$$

```{r plot_abnormal_features}

#plot_features(cds, limits_expr = c(0, 15000))
```

Based on the above plots, we flag cells with more UMI than the defined threshold for the number of UMI's per cell.

```{r flag_UMI_outliers}

umi_threshold <- base::mean(cds$n.umi) + 3 * stats::sd(cds$n.umi)
cds$umi_outlier <- dplyr::if_else(monocle3::pData(cds)$n.umi >= umi_threshold, "UMI outlier", NA)
```


## Visualize doublet and UMI outliers.

Prior to removal of cells flagged as either being a potential doublet and/or having an abundant number of UMI, we first visually inspect where the cells lie within UMAP-space to assess the sanity of calling.

```{r show_table}
#| tbl-cap: "No. of cells flagged as UMI-outlier and/or doublet"
knitr::kable(table(cds$umi_outlier, cds$scDblFinder.class), align = 'c')

cds$status <- tibble::as_tibble(monocle3::pData(cds)) %>% tidyr::unite(., col = 'status', scDblFinder.class, umi_outlier, na.rm = TRUE, sep = '+') %>% dplyr::pull(status)
```

```{r plot_umap_outliers}
#| label: fig-umap_filter
#| fig-cap: "Overview of potential doublets and/or UMI-outliers. Cells are colored based on singlet/doublet and or UMI-outlier status."
#| cap-location: margin
#| fig-align: center
monocle3::plot_cells(
    cds,
    color_cells_by = "status",
    cell_size = 0, label_cell_groups = FALSE
) + 
    ggplot2::geom_point(mapping = ggplot2::aes(alpha = status, color = status, size = status)) +
    ggplot2::scale_color_manual(values = c('singlet' = '#DAD2CB', 'doublet' = '#D4182E', 'doublet+UMI outlier' = '#F14694', 'singlet+UMI outlier' = 'darkblue')) +
    ggplot2::scale_alpha_manual(values = c('singlet' = .1, 'doublet' = 1, 'doublet+UMI outlier' = 1, 'singlet+UMI outlier' = 1)) +
    ggplot2::scale_size_manual(values = c('singlet' = .1, 'doublet' = 2, 'doublet+UMI outlier' = 2, 'singlet+UMI outlier' = 2)) +
    scir::theme_ggplot() +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    ggplot2::theme(legend.position = "right")

ggsave("../data/figures/fcg_mess_doublets.png", width = 5, height = 5)
```

## Removal of doublets and UMI outliers.

We remove cells reported as doublets and/or being UMI outliers.

```{r filter_cells}
#| tbl-cap: "Overview of cells filtered based on UMI count."

# Filter cells based on UMI count.
cells_prior <- base::ncol(cds)
cds <- cds[,cds$status == "singlet"]
cells_post <- base::ncol(cds_filt)
cells_lost <- cells_prior - cells_post

# Print table.
knitr::kable(
  base::data.frame(
    cells_prior = cells_prior,
    cells_post = cells_post,
    cells_lost = cells_lost,
    perc_lost = round(cells_lost / cells_prior * 100, 1)
  )
)
```

## Sanity check - UMAP.

In order to assess the initial pre-processing, we inspect the UMAP and visually determine possible batch-effects and sanity of major cell clusters.

```{r plot_umap}
#| label: fig-umap
#| fig-cap: "UMAP of all genes (n=25,064) and cells (n=131,975) on 20 PCs."
#| cap-location: margin
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = FALSE,
    show_trajectory_graph = FALSE,
    color_cells_by = "group",
    cell_size = 0.5) +
    # Theme.
    # ggplot2::scale_fill_manual(values = color_palette) +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    scir::theme_ggplot() +
    ggplot2::theme(legend.position = "right")

ggsave("../data/figures/fcg_mess_genotype_umap.png", width = 5, height = 5)
```

## QC - plot umi counts

```{r plot_umi_umap}
#| label: fig-umap
#| fig-cap: "UMAP colored by the number of umis per cell (log10)."
#| cap-location: margin
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = FALSE,
    show_trajectory_graph = FALSE,
    color_cells_by = "log.n.umi",
    cell_size = 0.5
) +
    # Theme.
    scale_color_viridis_c() +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    scir::theme_ggplot() +
    ggplot2::theme(legend.position = "right")

ggsave("../data/figures/fcg_mess_n-umi_umap.png", width = 5, height = 5)
```


## Annotate celltypes 

Plot clusters: 

```{r plot_clusters}

# revise cluster resolution
# cds <- monocle3::cluster_cells(cds, cluster_method = "leiden", resolution = 2e-5)

monocle3::plot_cells(cds, 
                     color_cells_by = "cluster", 
                     group_label_size = 4)

ggsave("../data/figures/fcg_mess_aligned_filt-clusters_2e-5res.png")

# cluster num? 
length(unique(clusters(cds)))

```
### Annotate cell types

```{r cluster_and_celltype_markers}

#| eval: false
# Calculate top markers
marker_test_res <- monocle3::top_markers(
  cds = cds, 
  genes_to_test_per_group = 30,
  group_cells_by = "cell_type_group", # previously, cluster
  cores = 8
)

# Filter on specificity to cluster.
cluster_markers <- marker_test_res %>% 
  #dplyr::mutate(cell_group = as.numeric(cell_group)) %>% # when cluster
  dplyr::filter(specificity >= 0.1) %>%
  dplyr::arrange(cell_group, -specificity)

# Save cluster markers for future use.
# write cluster markers.
readr::write_csv(
  x = cluster_markers, 
  file = "../data/tables/fcg_transloc_cluster_markers.csv")

# write celltype markers (some clusters merged)
readr::write_csv(
  x = cluster_markers, 
  file = "../data/tables/fcg_transloc_celltype-grp_markers.csv")

```


With this information, we can assign cell type annotations:


```{r celltype_update}

# add clusters to metadata
colData(cds)$cluster_n29 <- clusters(cds)

# add cell type to coldata
colData(cds)$cell_type_aligned <- colData(cds) %>% 
  as.data.frame() %>% 
  mutate(cell_type = case_when(
    cluster_n29 %in% c(3,4,6,7,8,9,13,15,16,19,21,27) ~ "Hepatocyte 1",
    cluster_n29 %in% c(1,2,5) ~ "Hepatocyte 2",
    cluster_n29 == 17 ~ "Hepatocyte 3",
    cluster_n29 == 14 ~ "Kupffer cell",
    cluster_n29 %in% c(12, 26) ~ "Macrophage/Immune cell mixed",
    cluster_n29 %in% c(11,22) ~ "Hepatic Stellate cell",
    cluster_n29 %in% c(10, 23) ~ "Endothelial cell",
    cluster_n29 == 25 ~ "Cholangiocyte",
    cluster_n29 == 18 ~ "unknown",
    cluster_n29 == 20 ~ "B cell",
    cluster_n29 == 24 ~ "T cell",
    cluster_n29 %in% c(28,29) ~ "NK cell",
    TRUE ~ "unknown")) %>% 
  pull(cell_type)

```
### Save `monocle3` object.

```{r save_cds}
saveRDS(cds, "../data/rdata/fcg_mess_grp-aligned_cds2.RDS")
```


### Plot post-alignment celltypes - Supplemental Figure 3

```{r plot_aligned_celltypes}

# pick colors
vibrant.colors <-  c('#EE7733', '#4477AA', '#228833', '#66CCEE', '#EE3377', '#CC3311',
    '#AA3377', '#009988', '#004488', '#DDAA33', '#99CC66','#D590DD', '#CCBB44', '#BBBBBB')

num.colors.type <- length(unique(colData(cds)$cell_type_aligned))
celltype.colors <- colorRampPalette(c(vibrant.colors))(num.colors.type) 

# plot cell types with labels
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = TRUE,
    group_label_size = 4,
    show_trajectory_graph = FALSE,
    label_groups_by_cluster = FALSE,
    color_cells_by = "cell_type_aligned",
    cell_size = 0.3
) +
    # Theme.
    ggplot2::scale_color_manual(values = celltype.colors) +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    theme_void() +
    ggplot2::theme(legend.position = "none")

ggsave("../data/figures/fcg_mess_aligned_celltype_umap_wL.png", width = 6, height = 5)

# plot cell types without labels
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = FALSE,
    show_trajectory_graph = FALSE,
    color_cells_by = "cell_type_aligned",
    cell_size = 0.3
) +
    # Theme.
    ggplot2::scale_color_manual(values = celltype.colors) +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    theme_void() +
    ggplot2::theme(legend.position = "none")

ggsave("../data/figures/fcg_mess_aligned_celltype_umap.png", width = 6, height = 5)

```

There are multiple Hepatocyte clusters that we want to merge for our analysis, so we will do that here:

```{r add_broad_labels}

colData(cds)$cell_type_group <- colData(cds) %>% 
  as.data.frame() %>% 
  mutate(cell_type_group = case_when(grepl("Hepatocyte", cell_type_aligned) ~ "Hepatocyte",
                                     TRUE ~ cell_type_aligned)) %>% 
  pull(cell_type_group)

```

```{r plot_broad_groups}

# pick colors
vibrant.colors <-  c('#EE7733', '#4477AA', '#228833', '#66CCEE', '#EE3377', '#CC3311',
    '#AA3377', '#009988', '#004488', '#DDAA33', '#99CC66','#D590DD', '#CCBB44', '#BBBBBB')

num.colors.type <- length(unique(colData(cds)$cell_type_group))
celltype.colors <- colorRampPalette(c(vibrant.colors))(num.colors.type) 

# plot cell types with labels
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = TRUE,
    group_label_size = 4,
    show_trajectory_graph = FALSE,
    label_groups_by_cluster = FALSE,
    color_cells_by = "cell_type_group",
    cell_size = 0.3
) +
    # Theme.
    ggplot2::scale_color_manual(values = celltype.colors) +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    theme_void() +
    ggplot2::theme(legend.position = "none")

ggsave("../data/figures/fcg_mess_celltype_hep-combined_umap_wL.png", width = 6, height = 5)

# plot cell types without labels
monocle3::plot_cells(
    cds = cds,
    reduction_method = "UMAP",
    label_cell_groups = FALSE,
    show_trajectory_graph = FALSE,
    color_cells_by = "cell_type_group",
    cell_size = 0.3
) +
    # Theme.
    ggplot2::scale_color_manual(values = celltype.colors) +
    ggplot2::labs(x = "UMAP1", y = "UMAP2") +
    theme_void() +
    ggplot2::theme(legend.position = "none")

ggsave("../data/figures/fcg_mess_celltype_hep-aligned_umap.png", width = 6, height = 5)

```

Make stacked barplot of cell type proportions: 

```{r stacked_bar}

coldat <- colData(cds) %>% 
  as.data.frame()

coldat %>% 
    left_join(samp_labels_df %>% 
              select(sample, samp_label), by = "sample") %>%
  ggplot(aes(x = factor(samp_label, levels = samp_levels), fill = cell_type_group)) + 
  geom_bar(pos = "fill", col = "black", width=0.5, size = 0.2) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x="",y="cell type %") + 
  scale_fill_manual(values = celltype.colors) +
  theme_bw() +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line.y.left  = element_line(color = 'black', linewidth =.8), 
        panel.border = element_blank(),
        axis.text.x = element_text(angle = 60, vjust = 1, hjust=1, size = 8), 
        axis.text.y = element_text(size = 8),
        text=element_text(family="sans"))

ggsave("../data/figures/fcg_mess_celltype_prop_barplot.pdf", width = 6, height = 3)

```
Plot celltype marker dot plot.

```{r marker_dotplot}

# load markers from file: 
celltype_markers <- fread("../data/tables/fcg_transloc_celltype-grp_markers.csv", sep = ",")

# plot 
top_specific_markers <- celltype_markers %>%
  dplyr::filter(cell_group != "unknown") %>% 
  dplyr::filter(fraction_expressing >= 0.1) %>%
  dplyr::group_by(cell_group) %>%
  dplyr::top_n(3, specificity)

hm_genes <- c(unique(top_specific_markers$gene_short_name),"Cyp2e1", "Apob")

monocle3::plot_genes_by_group(
  cds = cds[,colData(cds)$cell_type_group != "unknown"],
  markers = hm_genes,
  group_cells_by = "cell_type_group",
  ordering_type = "maximal_on_diag",
  max.size = 4) +
  scale_colour_gradient(low = "white", high = "black") +
  theme_paper() +
  labs(x="",y="")

ggsave("../data/figures/liver_celltype_marker_dotplot.pdf", width = 4, height = 5.5)
```


### Generate single cell QC plots - Supplemental Figure 1.

```{r supp_qc}

# sample colors
fcg_cols <- c("XXO" = "#000000", 
              "XXT" = "#6F6F6E",
              "XYO" = "#B1B1B1",
              "XYT" = "#ECECEC",
              "XYT-WT" = "#DBC6A9")

# extract metadata
coldat <- colData(cds) %>% 
  as.data.frame()

# clean up labels
samp_labels_df <- coldat %>%
  select(sample, group) %>%
  arrange(group) %>% 
  distinct() %>%
  mutate(group = factor(group, levels = c("XXO", "XXT", "XYO", "XYT", "XYT-WT"))) %>%
  group_by(group) %>%
  mutate(position = sprintf("%02d", row_number())) %>% 
  ungroup() %>% 
  mutate(samp_label = paste0(group, "-B6-", position))
  
samp_levels <- samp_labels_df %>% 
  arrange(group) %>% 
  distinct() %>%
  pull(samp_label)

# umi counts
ggplot(coldat %>% 
         left_join(samp_labels_df %>% 
              select(sample, samp_label), by = "sample"), aes(x = factor(samp_label, levels = samp_levels), y = n.umi, fill = group)) + 
  geom_violin(size=0.3, trim=FALSE)+
  scale_y_log10(limits = c(100, 100000), 
                breaks = scales::trans_breaks("log10", function(x) 10^x, n=4), 
                labels = scales::trans_format("log10", scales::math_format(10^.x))) +
  theme_bw() +
  labs(x="",y="UMI counts per cell") +
  scale_fill_manual(values = fcg_cols) +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none")

ggsave("../data/figures/liver_FCGM_umi-violin.pdf", width = 4, height = 3.5)

# gene counts
ggplot(coldat %>% 
         left_join(samp_labels_df %>% 
              select(sample, samp_label), by = "sample"), aes(x = factor(samp_label, levels = samp_levels), y = num_genes_expressed, fill = group)) + 
  geom_violin(size=0.3, trim=FALSE)+
  scale_y_log10(limits = c(100, 10000), 
                breaks = scales::trans_breaks("log10", function(x) 10^x, n=4), 
                labels = scales::trans_format("log10", math_format(10^.x))) +
  # scale_x_discrete(limits=samples, labels=samples.test) +
  theme_bw() +
  labs(x="",y="Genes expressed per cell") +
  scale_fill_manual(values = fcg_cols) +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none")

ggsave("../data/figures/liver_FCGM_genes-violin.pdf", width = 4, height = 3.5)

# number of cells per sample
summary_df <- coldat %>% 
  select(cell, sample, group) %>% 
  group_by(sample) %>% 
  mutate(cells_per_sample = sum(n())) %>% 
  select(-cell) %>% 
  distinct() %>% 
  left_join(samp_labels_df %>% 
              select(sample, samp_label), by = "sample")

summary_df %>% 
  arrange(-cells_per_sample)

ggplot(summary_df, aes(x = factor(samp_label, 
                                  levels = samp_levels), 
                       y = cells_per_sample, fill = group)) + 
  geom_col(color = "black", size = 0.3) + 
  scale_y_continuous(breaks = c(0, 3000, 6000, 9000), 
                     limits = c(0, 9000), expand = c(0,0)) +
  theme_bw() +
  labs(x="",y="Number of cells per sample") +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none") +
  scale_fill_manual(values = fcg_cols)
  
ggsave("../data/figures/liver_FCGM_cells-barplot.pdf", width = 4, height = 3.5)

```

### Examine the fraction of total counts from the X/Y chr per sample - Supplemental Figure 2.

```{r x_chr_check}

coldat <- colData(cds) %>% 
  as.data.frame()

# filter the data for only the x chr
x_genes <- rowData(cds) %>% 
  as.data.frame() %>% 
  filter(gene_chr == "chrX") %>% 
  pull(id)

x_genes <- rownames(rowData(cds)[rowData(cds)$id %in% x_genes,])

length(x_genes) # 925 genes on the X chromosome

# add X-chr counts
coldat$Xchr_umis <- colSums(counts(cds[x_genes,]))
coldat$Xist_umis <- counts(cds)["ENSMUSG00000086503.5",] # this is the Xist id

table(duplicated(rowData(cds)$id))

# rowData(cds) %>% 
#   as.data.frame() %>% 
#   filter(grepl("Sry", gene_short_name)) 

# plot % X-chr counts
plot_df <- coldat %>%
  select(cell, sample, n.umi, Xchr_umis) %>%
  group_by(sample) %>% 
  summarize(sample_umis = sum(n.umi),
            sample_Xchr_umis = sum(Xchr_umis)) %>%
  distinct() %>% 
  ungroup() %>% 
  left_join(samp_labels_df %>% 
              select(sample, samp_label, group), by = "sample") %>%
  mutate(Xchr_perc = sample_Xchr_umis/sample_umis * 100)

ggplot(plot_df, aes(x = factor(samp_label, 
                                  levels = samp_levels), 
                       y = Xchr_perc, fill = group)) + 
  geom_col(color = "black", size = 0.3) + 
  # scale_y_continuous(breaks = c(0, 5000, 10000, 15000), 
  #                    limits = c(0, 15000), expand = c(0,0)) +
  theme_bw() +
  labs(x="",y="% X chromosome counts") +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none") +
  scale_fill_manual(values = fcg_cols)

ggsave("../data/figures/Xchr_perc_counts-barplot.pdf", width = 4, height = 3.5)

# plot % Sry counts
plot_df <- coldat %>%
  select(cell, sample, n.umi, Xist_umis) %>%
  group_by(sample) %>% 
  summarize(sample_umis = sum(n.umi),
            sample_xist_umis = sum(Xist_umis)) %>%
  distinct() %>% 
  ungroup() %>% 
  left_join(samp_labels_df %>% 
              select(sample, samp_label, group), by = "sample") %>%
  mutate(xist_perc = sample_xist_umis/sample_umis * 100)

ggplot(plot_df, aes(x = factor(samp_label, 
                                  levels = samp_levels), 
                       y = xist_perc, fill = group)) + 
  geom_col(color = "black", size = 0.3) + 
  #scale_y_continuous(limits = c(0, 1), expand = c(0,0)) +
  theme_bw() +
  labs(x="",y="% Xist counts") +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", size=1),
        legend.position = "none") +
  scale_fill_manual(values = fcg_cols)

ggsave("../data/figures/Xist_perc_counts-barplot.pdf", width = 4, height = 3.5)

```

Y chromosome: 

```{r y_chr_check}

# do the same for the Y chromosome
y_genes <- rowData(cds) %>% 
  as.data.frame() %>% 
  filter(gene_chr == "chrY") %>% 
  pull(id)

y_genes <- rownames(rowData(cds)[rowData(cds)$id %in% y_genes,])

length(y_genes) # 40 genes on the Y

rowData(cds) %>% 
  as.data.frame() %>% 
  filter(grepl("Sry", gene_short_name))

# add Y-chr counts
coldat$Ychr_umis <- colSums(counts(cds[y_genes,]))
coldat$sry_umis <- counts(cds)["ENSMUSG00000069036.4",]

# plot % Y-chr counts
plot_df <- coldat %>%
  select(cell, sample, n.umi, Ychr_umis) %>%
  group_by(sample) %>% 
  summarize(sample_umis = sum(n.umi),
            sample_Ychr_umis = sum(Ychr_umis)) %>%
  distinct() %>% 
  ungroup() %>% 
  left_join(samp_labels_df %>% 
              select(sample, samp_label, group), by = "sample") %>%
  mutate(Ychr_perc = sample_Ychr_umis/sample_umis * 100)

ggplot(plot_df, aes(x = factor(samp_label, 
                                  levels = samp_levels), 
                       y = Ychr_perc, fill = group)) + 
  geom_col(color = "black", size = 0.3) + 
  scale_y_continuous() +
  theme_bw() +
  labs(x="",y="% Y chromosome counts") +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 8, colour = "black"), 
        axis.text.y = element_text(size = 8, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none") +
  scale_fill_manual(values = fcg_cols)

ggsave("../data/figures/Ychr_perc_counts-barplot.pdf", width = 4, height = 3.5)

# plot % Sry counts
plot_df <- coldat %>%
  select(cell, sample, n.umi, sry_umis) %>%
  group_by(sample) %>% 
  summarize(sample_umis = sum(n.umi),
            sample_sry_umis = sum(sry_umis)) %>%
  distinct() %>% 
  ungroup() %>% 
  left_join(samp_labels_df %>% 
              select(sample, samp_label, group), by = "sample") %>%
  mutate(sry_perc = sample_sry_umis/sample_umis * 100)

ggplot(plot_df, aes(x = factor(samp_label, 
                                  levels = samp_levels), 
                       y = sry_perc, fill = group)) + 
  geom_col(color = "black", size = 0.3) + 
  #scale_y_continuous(limits = c(0, 1), expand = c(0,0)) +
  theme_bw() +
  labs(x="",y="% Sry counts") +
  theme(axis.text.x = element_text(angle = 60, 
        vjust = 1, hjust=1, size = 6, colour = "black"), 
        axis.text.y = element_text(size = 6, colour = "black"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.ticks = element_line(color = "black"),
        panel.border = element_rect(fill=NA, colour = "black", linewidth=1),
        legend.position = "none") +
  scale_fill_manual(values = fcg_cols)

ggsave("../data/figures/Sry_perc_counts-barplot.pdf", width = 4, height = 3.5)

```
## Cell type proportions across individual mice: Supp Fig 4. 

```{r props}

fcg_cols <- c("XXO" = "#000000", 
              "XXT" = "#6F6F6E",
              "XYO" = "#B1B1B1",
              "XYT" = "#ECECEC",
              "XYT-WT" = "#DBC6A9")

# plot sample-specific celltype proportions as boxplots
colData(cds) %>% 
  as.data.frame() %>% 
  group_by(mouse_label, cell_type_group, group) %>% 
  summarize(n_cells = n()) %>% 
  ungroup() %>% 
  group_by(mouse_label, group) %>% 
  mutate(n_cells_per_sample = sum(n_cells),
         cell_type_group = forcats::fct_reorder(cell_type_group, n_cells),
         group = factor(group, levels = c("XYT", "XXT",  "XYO", "XXO", "XYT-WT"))) %>%
ggplot(aes(x = cell_type_group, y = n_cells / n_cells_per_sample, fill=group)) + 
  geom_boxplot(outlier.color = NA, width=0.7, position=position_dodge(width=0.8)) + 
  geom_jitter(color="black", size=0.3, position=position_dodge(width=0.8))  +
  geom_rangeframe(colour = "black", size=1) +
  theme_tufte() +
  # scale_x_discrete( labels=cell.label) +
  scale_y_log10(limits=c(0.001, 1)) +
  geom_vline(xintercept = 1:9 + 0.5, linetype = "dashed", col = "grey") +
  theme(axis.text.x = element_text(vjust=1, size = 8), 
        axis.text.y = element_text(size = 8), 
        plot.title = element_text(face = "bold"), legend.position="none",
        text=element_text(family="sans"),
        axis.ticks.length = unit(5, "pt"), axis.text = element_text(color = "black")) +
  labs(x="",y="log10 (cell proportion)") +
  scale_fill_manual(values = fcg_cols) + coord_flip()

ggsave("../data/figures/liver_cell_proportions_boxplot.pdf", width = 6, height = 5)

```



